<!DOCTYPE html>
<html lang="en">
<head>
    <title>phrased.expression.lexer</title>
    <meta charset="utf-8" />
    <style type="text/css">
        body
        {
            background-color: #D3D3D3;
        }
        
        tt
        {
            background-color: #B3B3B3;
        }
        
        table, tr, td
        {
            border-collapse: collapse;
            border: 1px solid black;
            padding: 5px;
        }
    </style>
</head>
<body>
    <h1>phrased.expression.lexer</h1>
    <!-- Generated by Ddoc from src/phrased/expression/lexer.d -->
Data structures and functions for lexing a string into a stream of tokens, to simplify later parsing.<br><br>

<dl><dt><big><a name="string_t"></a>alias string_t = immutable(dchar)[];
<br><a name="char_t"></a>alias char_t = dchar;
</big></dt>
<dd>The string and character type used throughout this module.
<br><br>
dstring/dchar are required by std.uni<br><br>

</dd>
<dt><big><a name="TokenType"></a>enum TokenType: int;
</big></dt>
<dd>The different types of tokens.<br><br>

<dl><dt><big><a name="TokenType.WORD"></a>WORD</big></dt>
<dd>A simple word<br><br>

</dd>
<dt><big><a name="TokenType.CHOICE_START"></a>CHOICE_START</big></dt>
<dd>The start of a choice expression (<tt>{</tt>)<br><br>

</dd>
<dt><big><a name="TokenType.CHOICE_END"></a>CHOICE_END</big></dt>
<dd>The end of a choice expression (<tt>}</tt>)<br><br>

</dd>
<dt><big><a name="TokenType.CHOICE_SEPARATOR"></a>CHOICE_SEPARATOR</big></dt>
<dd>The separator between elements of a choice expression (<tt>|</tt>)<br><br>

</dd>
<dt><big><a name="TokenType.MACRO_START"></a>MACRO_START</big></dt>
<dd>The start of a macro expression (<tt>$</tt> for simple ones and <tt>$(</tt> for complex ones)<br><br>

</dd>
<dt><big><a name="TokenType.MACRO_END"></a>MACRO_END</big></dt>
<dd>The end of a macro expression (empty for simple ones, and <tt>)</tt> for complex ones)<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="LexerException"></a>class LexerException: <u>phrased.PhrasedException</u>;
</big></dt>
<dd>The exception thrown when lexical analysis fails.<br><br>

</dd>
<dt><big><a name="Token"></a>struct Token;
</big></dt>
<dd>Representation of a single token<br><br>

<dl><dt><big><a name="Token.type"></a>TokenType type;
</big></dt>
<dd>The type of the token<br><br>

</dd>
<dt><big><a name="Token.value"></a>string_t value;
</big></dt>
<dd>The value of the token, if applicable<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="ExpressionLexer"></a>struct ExpressionLexer;
</big></dt>
<dd>A container for data used during lexing.
<br><br>
See <a href="#lex">lex</a> for the recommended way to use this.<br><br>

<dl><dt><big><a name="ExpressionLexer.result"></a>Token[] result;
</big></dt>
<dd>The resulting sequence of tokens from a successful lex<br><br>

</dd>
<dt><big><a name="ExpressionLexer.this"></a>this(string_t <i>expression</i>);
</big></dt>
<dd>Populate internal data structures and perform lexical analysis.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="lex"></a>Token[] lex(StringType)(StringType <i>source</i>) if (is(StringType == string) || is(StringType == wstring) || is(StringType == dstring));
</big></dt>
<dd>Shortcut to instantiate <a href="#ExpressionLexer">ExpressionLexer</a> and get the result.<br><br>

</dd>
</dl>

</body>
</html>
