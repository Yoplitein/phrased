<!DOCTYPE html>
<html lang="en">
<head>
    <title>phrased.expression.parser</title>
    <meta charset="utf-8" />
    <style type="text/css">
        body
        {
            background-color: #D3D3D3;
        }
        
        tt
        {
            background-color: #B3B3B3;
        }
        
        table, tr, td
        {
            border-collapse: collapse;
            border: 1px solid black;
            padding: 5px;
        }
    </style>
</head>
<body>
    <h1>phrased.expression.parser</h1>
    <!-- Generated by Ddoc from src/phrased/expression/parser.d -->
Data structures and functions for parsing a stream of tokens into a tree of <a href="#Node">Node</a>s,
    which can then be resolved into a string.<br><br>

<dl><dt><big><a name="ParserException"></a>class ParserException: <u>phrased.PhrasedException</u>;
</big></dt>
<dd>The exception thrown when parsing fails.<br><br>

</dd>
<dt><big><a name="Node"></a>interface Node;
</big></dt>
<dd>Basic interface of a node in the expression tree.<br><br>

<dl><dt><big><a name="Node.resolve"></a>abstract string resolve();
</big></dt>
<dd>Resolve this node, and any subnodes, into a string.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="SequenceNode"></a>class SequenceNode: <u>phrased.expression.parser.Node</u>;
</big></dt>
<dd>A node containing a sequence of subnodes, referred to as children.<br><br>

<dl><dt><big><a name="SequenceNode.children"></a>Appender!(Node[]) children;
</big></dt>
<dd>The children within this node<br><br>

</dd>
<dt><big><a name="SequenceNode.this"></a>this();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="SequenceNode.this"></a>this(Node[] <i>children</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="SequenceNode.put"></a>void put(Node <i>node</i>);
</big></dt>
<dd>Add a child <i>node</i> to the end of the list of children.<br><br>

</dd>
<dt><big><a name="SequenceNode.length"></a>size_t length();
</big></dt>
<dd>Returns the number of child nodes.<br><br>

</dd>
<dt><big><a name="SequenceNode.empty"></a>bool empty();
</big></dt>
<dd>Returns whether there are any children in this node.<br><br>

</dd>
<dt><big><a name="SequenceNode.resolve"></a>string resolve();
</big></dt>
<dd>See <a href="#Node.resolve">Node.resolve</a>.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="WordNode"></a>class WordNode: <u>phrased.expression.parser.Node</u>;
</big></dt>
<dd>A node containing a single word.<br><br>

<dl><dt><big><a name="WordNode.contents"></a>string contents;
</big></dt>
<dd>The word contained in this node<br><br>

</dd>
<dt><big><a name="WordNode.resolve"></a>string resolve();
</big></dt>
<dd>See <a href="#Node.resolve">Node.resolve</a>.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="MacroNode"></a>class MacroNode: <u>phrased.expression.parser.Node</u>;
</big></dt>
<dd>A node representing a macro expression.<br><br>

<dl><dt><big><a name="MacroNode.name"></a>WordNode name;
</big></dt>
<dd>The name of the macro<br><br>

</dd>
<dt><big><a name="MacroNode.arguments"></a>SequenceNode arguments;
</big></dt>
<dd>The arguments to the macro<br><br>

</dd>
<dt><big><a name="MacroNode.this"></a>this();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="MacroNode.this"></a>this(WordNode <i>name</i>, SequenceNode <i>arguments</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="MacroNode.resolve"></a>string resolve();
</big></dt>
<dd>See <a href="#Node.resolve">Node.resolve</a>.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="ChoiceNode"></a>class ChoiceNode: <u>phrased.expression.parser.SequenceNode</u>;
</big></dt>
<dd>A node representing a choice expression.
<br><br>
Inherits from <a href="#SequenceNode">SequenceNode</a> as the functionality is mostly the same,
    except a single child node is chosen while resolving, instead of concatenating them all.
    The empty string is resolved if there are no children.<br><br>

<dl><dt><big><a name="ChoiceNode.this"></a>this();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="ChoiceNode.this"></a>this(Node[] <i>choices</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="ChoiceNode.resolve"></a>string resolve();
</big></dt>
<dd>See <a href="#Node.resolve">Node.resolve</a>.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="ExpressionParser"></a>struct ExpressionParser;
</big></dt>
<dd>A container for data used during parsing.
<br><br>
See <a href="#parse">parse</a> for the recommended way to use this.<br><br>

<dl><dt><big><a name="ExpressionParser.result"></a>SequenceNode result;
</big></dt>
<dd>The resulting SequenceNode from a successful parse<br><br>

</dd>
<dt><big><a name="ExpressionParser.this"></a>this(Token[] <i>tokens</i>);
</big></dt>
<dd>Populate internal data structures and peform parsing.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="parse"></a>SequenceNode parse(Token[] <i>tokens</i>);
</big></dt>
<dd>Shortcut to instantiate <a href="#ExpressionParser">ExpressionParser</a> and get the result.<br><br>

</dd>
</dl>

</body>
</html>
